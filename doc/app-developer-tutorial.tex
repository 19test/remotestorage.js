% Created 2012-10-01 Mon 14:16
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\providecommand{\alert}[1]{\textbf{#1}}

\title{app-developer-tutorial}
\author{nil}
\date{\today}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs Org-mode version 7.8.11}}

\begin{document}

\maketitle

\setcounter{tocdepth}{3}
\tableofcontents
\vspace*{1cm}
\section{App Developer Tutorial}
\label{sec-1}
\subsection{Introduction}
\label{sec-1-1}


   This guide is meant for web developers, who wish to write applications using remotestorage / remoteStorage.js.

   It explains basic concepts of both remotestorage and remoteStorage.js and provides an introduction to the JavaScript API of remoteStorage.js.
\subsection{Terms}
\label{sec-1-2}


   You don't need to know all of these, to develop an app.

\begin{itemize}
\item \textbf{unhosted} - When we say ``Unhosted Web App'', we mean applications written in javascript, that only run within the browser. For more information on the word unhosted, see it's \href{http://unhosted.org}{website}.
\item \textbf{remotestorage} - \href{http://remotestorage.io}{remotestorage} is a specification for the interaction between storage servers and web applications.
\item \textbf{remoteStorage.js} - This is the client side implementation of the remotestorage specification. Put simply, this is the file you include in your webapp, to make it talk remotestorage.
\item \textbf{CORS} - A \href{http://enable-cors.org/}{cool new feature} of the web platform, that lets an application from one server (origin actually), send AJAX requests to another server, without being prevented by the browser to do so (while adhering to restrictions given by that server being queried). As an app developer that uses remoteStorage.js you don't need to no anything about this, except that prevents you from worrying in many ways.
\end{itemize}
\subsection{remotestorage - storage for Unhosted Web Apps}
\label{sec-1-3}

   This is not an in-depth explaination of remotestorage. Just a quick glance to see what we'll be dealing with. If you want to know the details of remotestorage, I encourage you to read \href{http://www.w3.org/community/unhosted/wiki/RemoteStorage-2012.04}{the specification}.

   But before I explain any of what remotestorage is made of, let's take a look at how it's used.
\subsubsection{From a users perspective\ldots{}}
\label{sec-1-3-1}
\begin{itemize}

\item \ldots{} it may look like this:
\label{sec-1-3-1-1}%
\begin{itemize}
\item A friend sends me a link to a cool new app.
\item That app has a neat orange cube in the top right corner, designating the support for remotestorage in the application.
\item I click the cube, enter my useraddress (in the form of user@host) into the appearing textfield, then click ``connect''
\item Now I have been redirected to the authorization site of my storage provider.
\item If I haven't already logged into my storage, it will ask me to do so.
\item Now my storage provider shows me information on what permissions the app requests, once I accept that, I'm back at the app.
\item Now the app can read and write to my storage, restrained only through the permissions it requested.
\item Any other app can read and write the same data and hence interoperate.
\end{itemize}

     The scenario just described is what we call ``app-first''.


\item \ldots{} or it may look like this:
\label{sec-1-3-1-2}%
\begin{itemize}
\item A friend sends me a link to a cool new app.
\item I visit my storage provider's dashboard (which may already be open).
\item There I paste the link to the app, the app then gets installed on my dashboard.
\item Now I click the app's icon and it opens.
\item My storage provider has provided the app with the necessary information, it needs to know where my storage is.
\item So, as above: from now on the app can read and write to my storage.
\end{itemize}

     This is what we call the ``storage-first'' scenario.

\end{itemize} % ends low level
\subsubsection{From a developers perspective}
\label{sec-1-3-2}
\begin{itemize}

\item user addresses\\
\label{sec-1-3-2-1}%
User addresses look like email addresses: user@host.

     A user address is what the user in the ``app-first'' scenario provided to the app to make her storage provider known.

     The app (or rather remoteStorage.js) discovers both storage and authentication server based on the user address through a mechanism called \href{http://tools.ietf.org/html/draft-jones-appsawg-webfinger-06}{Webfinger}.

     In order to discover the storage of a user alice@wonderland.lit, the server at wonderland.lit is asked for information on the user alice. wonderland.lit then provides her profile, which contains links. One of these links is called ``remotestorage'' and contains the information the app needs.


\item authorization\\
\label{sec-1-3-2-2}%
The remotestorage specification chooses a subset (the ``implicit grant flow'') of \href{http://oauth.net/2/}{OAuth2} for authorization of apps to access storage.
     During that process, the app claims a set of permissions it wishes to have on the storage, the user is prompted to confirm those, then the authorization provider issues a bearer token and passes it back to the app by redirect.


\item exchanging data: GET, PUT, DELETE\\
\label{sec-1-3-2-3}%
The storage is accessed through regular HTTP requests:
\begin{itemize}
\item GET requests load data from the storage
\item PUT requests put data into the storage
\item DELETE requests destroy data on the storage
\end{itemize}

     The path can be any valid HTTP path. There is one exception though: Paths ending with a forward slash (/) represent ``directories''.
     A GET request to a directory always results in a JSON object, listing the direct child-nodes of that directory, and their respective mtime.
     Both PUT and DELETE requests to directory paths are illegal and have no effect.

     The permissions mentioned above, place a few restrictions on what paths exactly an app may GET, PUT or DELETE to.
     A single permissions statement consists of a \textbf{path} and a \textbf{mode}. The \textbf{path} is relative to the root of the storage and must represent a directory. The \textbf{mode} may either be ``r'' for ``read'', or ``rw'' for read-write.
     When access to a given \textbf{path} has been requested and confirmed, only requests to that path and nodes below it can be performed by the app.


\item public data\\
\label{sec-1-3-2-4}%
An exception to the permission model described in the last paragraph applies to all paths starting with the string ``public/''.
     Non-directory nodes (aka files, i.e. those paths not ending in a slash) can be read (GET) by anyone without authorization.
     Directory nodes on the other hand can only be read, with sufficient permissions. Also PUT and DELETE requests require authorization.

     By definition, when granted permission to read / write at a given path, permission to write at the same path prefixed with public/ as well is granted implicitly.
     That is, if an app requests to read-write to ``tasks/'', it can also read-write to ``public/tasks/''.

     That way sharing of data can be implemented.
     
\end{itemize} % ends low level
\subsection{remoteStorage.js - accessing remotestorage from an App}
\label{sec-1-4}


   \href{https://github.com/RemoteStorage/remoteStorage.js}{remoteStorage.js} is a client side implementation of remotestorage in JavaScript.

   It provides the following things for an app developer:

\begin{itemize}
\item A widget, through which the user controls it's connection to remotestorage.
\item A set of modules to interact with common kinds of data (such as list of friends/contacts, locations, photos, \ldots{}).
\item An interface to write a module which models the data your app works with.
\end{itemize}

   As the rest of this document is about remoteStorage.js, I won't say any more about it here, but instead get you set up with remotestorage first, in the next paragraph.
\subsection{Setting up remotestorage}
\label{sec-1-5}
\subsubsection{Get developer access}
\label{sec-1-5-1}
\begin{itemize}

\item heahdk.net\\
\label{sec-1-5-1-1}%
\href{https://heahdk.net/}{heahdk.net} is the staging instance for \href{https://github.com/RemoteStorage/remotestorage-ruby}{remotestorage-ruby}. You can simply \href{https://heahdk.net/users/new}{signup}, and you're good to go.
     Your \textbf{user address} will be <login>@heahdk.net.
     remotestorage-ruby also supports the storage-first scenario.

\item 5apps.com\\
\label{sec-1-5-1-2}%
\href{http://5apps.com/}{5apps} provides storage for developers. Sign up regularly on 5apps, then ask in the \#5apps IRC channel for remotestorage developer access.

\item owncube.com\\
\label{sec-1-5-1-3}%
\href{https://owncube.com}{owncube} is a hosted \href{http://owncloud.org}{owncloud} service. It uses the owncloud plugin for remotestorage. This might not work with remoteStorage.js 0.7, see \href{https://github.com/RemoteStorage/remoteStorage.js/issues/52}{this issue} for status.
\end{itemize} % ends low level
\subsubsection{Set up your own}
\label{sec-1-5-2}

    The \href{https://github.com/unhosted/website/wiki/State-of-the-movement}{State of the movement page} has a list of compatible storage software.
\subsection{Getting remoteStorage.js}
\label{sec-1-6}
\subsubsection{Include the script}
\label{sec-1-6-1}

    As remoteStorage.js is still a moving target, as of this writing I suggest you use the HEAD version, directly from github:

\begin{verbatim}
<script src="https://raw.github.com/RemoteStorage/remoteStorage.js/master/build/0.7.0-head/remoteStorage.js"></script>
\end{verbatim}
    or the debug version:

\begin{verbatim}
<script src="https://raw.github.com/RemoteStorage/remoteStorage.js/master/build/0.7.0-head/remoteStorage-debug.js"></script>
\end{verbatim}
\subsubsection{Using git}
\label{sec-1-6-2}

    You can clone remoteStorage.js like this:

\begin{verbatim}
git clone git://github.com/RemoteStorage/remoteStorage.js
\end{verbatim}
\subsection{Let's hit the code!}
\label{sec-1-7}
\subsubsection{A skeleton}
\label{sec-1-7-1}


    So, after a lot of preface, now some code:


\begin{verbatim}
<!DOCTYPE html>
<html>
  <head>
    <script src="https://raw.github.com/RemoteStorage/remoteStorage.js/master/build/0.7.0-head/remoteStorage-modules.js"></script>
    <script src="app.js"></script>
  </head>
  <body>
    <div id="remotestorage-widget"></div>
  </body>
</html>
\end{verbatim}

    what you see above, is the basic skeleton. It contains the bare minimum for a remotestorage app:
\begin{itemize}
\item the remoteStorage.js library
\item a <div/> placeholder for the widget
\item the app's code, within app.js
\end{itemize}
  
    I haven't shown you the app's code yet, so here it goes:


\begin{verbatim}
window.onload = function() {

  remoteStorage.claimAccess({ 'tasks' : 'rw' });
  remoteStorage.displayWidget('remotestorage-widget');

}
\end{verbatim}

    This does two things:
\begin{itemize}
\item Set permissions the app wishes to have (in this case it wishes to ``read'' (GET) and ``write'' (PUT, DELETE) data in the ``tasks'' category)
\item Display the widget, within the placeholder div.
\end{itemize}
  
    As soon as the widget is visible, the user may interact with it, so at that point all permissions must have been requested. In other words, all calls to \textbf{claimAccess} MUST come before the call to \textbf{displayWidget}.
\subsubsection{Common data: tasks}
\label{sec-1-7-2}


    

\end{document}
